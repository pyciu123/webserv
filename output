-e 
===== ./Makefile =====
NAME = webserv

SRCS = $(wildcard src/*.cpp)
INC = $(wildcard includes/*.hpp)

all: $(NAME)

$(NAME): $(SRCS) $(INC)
	c++ -Wall -Wextra -Werror -std=c++98 -Iincludes -g -fsanitize=address $(SRCS) -o $(NAME)

clean:
	rm -f *.o

fclean: clean
	rm -f $(NAME)

re: fclean all-e 
===== ./includes/Server.hpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:55:37 by pmilek            #+#    #+#             */
/*   Updated: 2025/06/12 11:05:36 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVER_HPP
# define SERVER_HPP

#include "../includes/Webserv.hpp"
#include "../includes/HttpRequestParse.hpp"
#include "../includes/HttpResponse.hpp"
#include "../includes/ConfigParser.hpp"

class Server {
	private:
		int server_fd;
		int port;
		sockaddr_in address;
		ServerConfig config;

		int acceptConnection();
		std::string generateResponse(const HttpRequestParse &req);
		void sendResponse(int client_id, const std::string &response);
		std::string reciveRequest(int client_fd);

	public:
		Server(const ServerConfig &cfg);
		~Server();

		// methods
		void setupSocket();
		void run();

		// getters
		int getPort();
};

#endif
-e 
===== ./includes/HttpResponse.hpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpResponse.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:55:33 by pmilek            #+#    #+#             */
/*   Updated: 2025/07/21 10:07:21 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HTTPRESPONSE_HPP
# define HTTPRESPONSE_HPP

#include "../includes/HttpRequestParse.hpp"
#include "../includes/Webserv.hpp"
#include "../includes/CgiHandler.hpp"

class HttpResponse
{
	private:
		ServerConfig _config;
		int _status;
		std::string _statusMessage;
		std::string _handleCgi(const HttpRequestParse &req);
		bool _exists(const std::string &path);
		std::string _readFile(const std::string &path);
	
	public:
		HttpResponse(const ServerConfig &cfg);
		HttpResponse(const HttpResponse &copy);
		HttpResponse &operator=(const HttpResponse &other);
		~HttpResponse();

		// methods
		std::string buildResponse(const HttpRequestParse &req);

};

#endif-e 
===== ./includes/ConfigParser.hpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ConfigParser.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:59:11 by pmilek            #+#    #+#             */
/*   Updated: 2025/07/21 09:35:09 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CONFIGPARSER_HPP
#define CONFIGPARSER_HPP

#include "../includes/Webserv.hpp"

class ConfigParser {
	private:
		std::string _filepath;
		ServerConfig _serverConfig;

	public:
		ConfigParser(const std::string &path);
		void parse();
		ServerConfig getServerConfig() const;
};

#endif
-e 
===== ./includes/CgiHandler.hpp =====
#ifndef CGIHANDLER_HPP
# define CGIHANDLER_HPP

#include "../includes/Webserv.hpp"

class CgiHandler
{
	private:
		std::string _scriptPath;
		std::map<std::string, std::string> _env;
		std::string _body;
		std::string _interpreter;
	
	public:
    	CgiHandler(const std::string &path, const std::map<std::string, std::string> &env, const std::string &body, const std::string interpreter);
		CgiHandler(const CgiHandler &copy);
		CgiHandler &operator=(const CgiHandler &other);
		~CgiHandler();
		std::string execute();
};

#endif-e 
===== ./includes/Webserv.hpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Webserv.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:55:41 by pmilek            #+#    #+#             */
/*   Updated: 2025/06/12 11:01:39 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef WEBSERV_HPP
# define WEBSERV_HPP

// c
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

// c++
#include <iostream>
#include <cstring>
#include <map>
#include <sstream>
#include <fstream>
#include <utility>
#include <vector>

struct LocationConfig {
	std::string path;
	std::vector<std::string> methods;
	std::string upload_path;
	std::vector<std::string> index;
	bool autoindex;
	std::pair<int, std::string> redirection;
	std::string cgi_extension;
	std::string cgi_path;

	LocationConfig() : autoindex(false), redirection(std::make_pair(0, "")) {}
};

struct ServerConfig {
	int port;
	std::string root;
	size_t client_max_body_size;
	std::map<int, std::string> error_pages;
	std::vector<LocationConfig> locations;
	std::vector<std::string> server_names;
};

#endif-e 
===== ./includes/HttpRequestParse.hpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpRequestParse.hpp                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:55:26 by pmilek            #+#    #+#             */
/*   Updated: 2025/07/21 09:35:15 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HTTPREQUESTPARSE
# define HTTPREQUESTPARSE

#include "../includes/Webserv.hpp"

class HttpRequestParse {
	private:
		std::string _rawRequest;
		std::string	_method;
		std::string _path;
		std::string _httpVersion;
		std::map<std::string, std::string> _headers;
		std::string _body;
		size_t _contentLength;
	
	public:
		HttpRequestParse(const std::string &rawRequest);
		HttpRequestParse(const HttpRequestParse &copy);
		HttpRequestParse &operator=(const HttpRequestParse &other);
		~HttpRequestParse();

		// methods
		void parseRequest();
		void printAll() const; // only for testin

		//getters
		std::string getMethod() const;
		std::string getPath() const;
		std::string getHttpVersion() const;
		std::map<std::string, std::string> getHeaders() const;
		std::string getBody() const;
		size_t getContentLength() const;
};

#endif-e 
===== ./src/HttpRequestParse.cpp =====
/* ************************************************************************** */
/*																			*/
/*														:::	  ::::::::   */
/*   HttpRequestParse.cpp							   :+:	  :+:	:+:   */
/*													+:+ +:+		 +:+	 */
/*   By: jpyciarz <jpyciarz@student.42.fr>		  +#+  +:+	   +#+		*/
/*												+#+#+#+#+#+   +#+		   */
/*   Created: 2025/06/11 14:55:46 by pmilek			#+#	#+#			 */
/*   Updated: 2025/07/21 10:09:55 by jpyciarz		 ###   ########.fr	   */
/*																			*/
/* ************************************************************************** */

#include "../includes/HttpRequestParse.hpp"

// constructors/destructor
HttpRequestParse::HttpRequestParse(const std::string &rawRequest) : _rawRequest(rawRequest), _path(""), _httpVersion(""), _body(""), _contentLength(-1) {}

HttpRequestParse::HttpRequestParse(const HttpRequestParse &copy)
{
	*this = copy;
}

HttpRequestParse &HttpRequestParse::operator=(const HttpRequestParse &other)
{
	if (this != &other)
	{
		_rawRequest = other._rawRequest;
		_path = other._path;
		_httpVersion = other._httpVersion;
		_headers = other._headers;
		_body = other._body;
		_method = other._method;
		_contentLength = other._contentLength;
	}
	return *this;
}

HttpRequestParse::~HttpRequestParse() {}


void HttpRequestParse::printAll() const
{
	std::cout << "Method: " << _method << std::endl;
	std::cout << "Path: " << _path << std::endl;
	std::cout << "HTTP Version: " << _httpVersion << std::endl;

	std::cout << "Headers:" << std::endl;
	for (std::map<std::string, std::string>::const_iterator it = _headers.begin(); it != _headers.end(); ++it)
	{
		std::cout << "  " << it->first << ": " << it->second << std::endl;
	}

	std::cout << "Body:\n" << _body << std::endl;
}

// methods
void HttpRequestParse::parseRequest()
{
	std::istringstream stream(_rawRequest);
	std::string line;
	bool isFirstLine = true;
	bool isHeaders = false;
	bool isBody = false;
	while (std::getline(stream, line))
	{
		line.erase(line.find_last_not_of("\r") + 1);

		if (isFirstLine) {
			std::istringstream iss(line);
			iss >> _method >> _path >> _httpVersion;
			if (_method.empty() || _path.empty() || _httpVersion.empty())
				throw std::runtime_error("400 Bad Request: invalid request line");

			isFirstLine = false;
			isHeaders = true;
			continue;
		}

		if (isHeaders) {
			if (line.empty()) {
				isHeaders = false;
				isBody = true;
				continue;
			}

			size_t pos = line.find(':');
			if (pos == std::string::npos)
				throw std::runtime_error("400 Bad Request: invalid header format");

			std::string key = line.substr(0, pos);
			std::string value = line.substr(pos + 1);
			value.erase(0, value.find_first_not_of(' '));
			_headers[key] = value;

			// Aktualizacja contentLength
			if (key == "Content-Length") {
				try {
					_contentLength = std::stoul(value);
				} catch (const std::exception& e) {
					throw std::runtime_error("400 Bad Request: invalid Content-Length");
				}
			}
			continue;
		}

		if (isBody)
			_body += line + '\n';
	}
}


// getters
std::string HttpRequestParse::getMethod() const
{
	return _method;
}

std::string HttpRequestParse::getPath() const
{
	return _path;
}

std::string HttpRequestParse::getHttpVersion() const
{
	return _httpVersion;
}

std::map<std::string, std::string> HttpRequestParse::getHeaders() const
{
	return _headers;
}

std::string HttpRequestParse::getBody() const
{
	return _body;
}

size_t HttpRequestParse::getContentLength() const
{
	return _contentLength;
}-e 
===== ./src/HttpResponse.cpp =====
/* ************************************************************************** */
/*																			*/
/*														:::	  ::::::::   */
/*   HttpResponse.cpp								   :+:	  :+:	:+:   */
/*													+:+ +:+		 +:+	 */
/*   By: jpyciarz <jpyciarz@student.42.fr>		  +#+  +:+	   +#+		*/
/*												+#+#+#+#+#+   +#+		   */
/*   Created: 2025/06/11 14:55:52 by pmilek			#+#	#+#			 */
/*   Updated: 2025/07/21 10:11:21 by jpyciarz		 ###   ########.fr	   */
/*																			*/
/* ************************************************************************** */

#include "../includes/HttpResponse.hpp"

// constuctors/destructors
HttpResponse::HttpResponse(const ServerConfig &cfg) : _config(cfg), _status(200), _statusMessage("") {}

HttpResponse::HttpResponse(const HttpResponse &copy)
{
	*this = copy;
}

HttpResponse &HttpResponse::operator=(const HttpResponse &other)
{
	if (this != &other)
	{
		_status = other._status;
		_statusMessage = other._statusMessage;
	}
	return *this;
}

HttpResponse::~HttpResponse() {}


// private methods
bool HttpResponse::_exists(const std::string &path)
{
	if (FILE *file = fopen(path.c_str(), "r"))
		return fclose(file), true;
	else
		return false;
}

std::string HttpResponse::_readFile(const std::string &path)
{
	std::ifstream file(path.c_str());
	if (!file.is_open())
		throw std::runtime_error("Failed to open file:" + path);
	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string content = buffer.str();
	return content;
}

std::string HttpResponse::_handleCgi(const HttpRequestParse &req) {
	std::string path = req.getPath();
	std::string method = req.getMethod();

	for (size_t i = 0; i < _config.locations.size(); ++i) {
		const LocationConfig &loc = _config.locations[i];

		bool methodAllowed = loc.methods.empty();
		for (size_t j = 0; j < loc.methods.size(); ++j) {
			if (loc.methods[j] == method) {
				methodAllowed = true;
				break;
			}
		}
		if (!methodAllowed) {
			continue;
		}

		if (path.find(loc.path) == 0 &&
			path.size() >= loc.cgi_extension.size() &&
			path.compare(path.size() - loc.cgi_extension.size(), loc.cgi_extension.size(), loc.cgi_extension) == 0) {
			std::map<std::string, std::string> env;
			env["REQUEST_METHOD"] = method;
			env["CONTENT_LENGTH"] = std::to_string(req.getContentLength());

			if (req.getHeaders().count("Content-Type"))
				env["CONTENT_TYPE"] = req.getHeaders().at("Content-Type");
			else
				env["CONTENT_TYPE"] = "text/plain";

			env["SCRIPT_NAME"] = path;
			env["QUERY_STRING"] = "";

			std::string interpreter = loc.cgi_path;
			std::string scriptPath = _config.root + path;
			std::string body = req.getBody();

			std::cerr << "Executing CGI: " << scriptPath << " with interpreter: " << interpreter << std::endl;
			std::cerr << "Body: " << body << std::endl;

			CgiHandler cgi(scriptPath, env, body, interpreter);
			std::string result = cgi.execute();

			std::ostringstream response;
			response << "HTTP/1.1 200 OK\r\n";
			response << "Content-Type: text/html\r\n";
			response << "Content-Length: " << result.size() << "\r\n";
			response << "Connection: close\r\n\r\n";
			response << result;
			return response.str();
		}
	}
	return "";
}

// Zmodyfikowana metoda buildResponse
std::string HttpResponse::buildResponse(const HttpRequestParse &req) {
	std::string response;

	// Obsługa CGI dla GET i POST
	if (req.getMethod() == "GET" || req.getMethod() == "POST") {
		response = _handleCgi(req);
		if (!response.empty()) {
			return response;
		}
	}

	// Standardowa obsługa GET (jeśli nie CGI)
	if (req.getMethod() == "GET") {
		std::string filePath = _config.root + req.getPath();
		if (_exists(filePath)) {
			std::string content = _readFile(filePath);
			std::ostringstream oss;
			oss << "HTTP/1.1 200 OK\r\n";
			oss << "Content-Type: text/html\r\n";
			oss << "Content-Length: " << content.size() << "\r\n";
			oss << "Connection: close\r\n\r\n";
			oss << content;
			return oss.str();
		} else {
			std::string msg = "404 Not Found";
			std::ostringstream oss;
			oss << "HTTP/1.1 404 Not Found\r\n";
			oss << "Content-Type: text/plain\r\n";
			oss << "Content-Length: " << msg.size() << "\r\n";
			oss << "Connection: close\r\n\r\n";
			oss << msg;
			return oss.str();
		}
	}
	// Obsługa POST (jeśli nie CGI)
	else if (req.getMethod() == "POST") {
		std::string msg = "POST request processed";
		std::ostringstream oss;
		oss << "HTTP/1.1 200 OK\r\n";
		oss << "Content-Type: text/plain\r\n";
		oss << "Content-Length: " << msg.size() << "\r\n";
		oss << "Connection: close\r\n\r\n";
		oss << msg;
		return oss.str();
	}
	// Obsługa DELETE
	else if (req.getMethod() == "DELETE") {
		std::string msg = "DELETE request processed";
		std::ostringstream oss;
		oss << "HTTP/1.1 200 OK\r\n";
		oss << "Content-Type: text/plain\r\n";
		oss << "Content-Length: " << msg.size() << "\r\n";
		oss << "Connection: close\r\n\r\n";
		oss << msg;
		return oss.str();
	}
	// Domyślna odpowiedź dla nieobsługiwanych metod
	else {
		std::string msg = "Method Not Allowed";
		std::ostringstream oss;
		oss << "HTTP/1.1 405 Method Not Allowed\r\n";
		oss << "Content-Type: text/plain\r\n";
		oss << "Content-Length: " << msg.size() << "\r\n";
		oss << "Connection: close\r\n\r\n";
		oss << msg;
		return oss.str();
	}
}-e 
===== ./src/ConfigParser.cpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ConfigParser.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:59:21 by pmilek            #+#    #+#             */
/*   Updated: 2025/06/12 10:56:32 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/ConfigParser.hpp"
#include "../includes/Webserv.hpp"

ConfigParser::ConfigParser(const std::string &path) : _filepath(path) {}

void ConfigParser::parse() {
	std::ifstream file(_filepath.c_str());
	if (!file.is_open())
		throw std::runtime_error("Could not open config file");

	std::string line;
	LocationConfig currentLocation;
	bool inLocation = false;

	while (std::getline(file, line)) {
		std::istringstream iss(line);
		std::string key;
		iss >> key;

		if (key == "listen") {
			iss >> _serverConfig.port;
		}
		else if (key == "root") {
			iss >> _serverConfig.root;
		}
		else if (key == "client_max_body_size") {
			iss >> _serverConfig.client_max_body_size;
		}
		else if (key == "server_name") {
			std::string name;
			while (iss >> name)
				_serverConfig.server_names.push_back(name);
		}
		else if (key == "error_page") {
			int code;
			std::string path;
			iss >> code >> path;
			_serverConfig.error_pages[code] = path;
		}
		else if (key == "location") {
			inLocation = true;
			iss >> currentLocation.path;
		}
		else if (key == "methods" && inLocation) {
			std::string method;
			while (iss >> method)
				currentLocation.methods.push_back(method);
		}
		else if (key == "upload_path" && inLocation) {
			iss >> currentLocation.upload_path;
		}
		else if (key == "index" && inLocation) {
			std::string file;
			while (iss >> file)
				currentLocation.index.push_back(file);
		}
		else if (key == "autoindex" && inLocation) {
			std::string val;
			iss >> val;
			currentLocation.autoindex = (val == "on");
		}
		else if (key == "return" && inLocation) {
			int code;
			std::string target;
			iss >> code >> target;
			currentLocation.redirection = std::make_pair(code, target);
		}
		else if (key == "cgi_extension" && inLocation) {
			iss >> currentLocation.cgi_extension;
		}
		else if (key == "cgi_path" && inLocation) {
			iss >> currentLocation.cgi_path;
		}
		else if (key == "}") {
			if (inLocation) {
				_serverConfig.locations.push_back(currentLocation);
				currentLocation = LocationConfig();
				inLocation = false;
			}
		}
	}
}

ServerConfig ConfigParser::getServerConfig() const {
	return _serverConfig;
}
-e 
===== ./src/CgiHandler.cpp =====
#include "../includes/CgiHandler.hpp"

// constructors/destructors
CgiHandler::CgiHandler(const std::string &path, const std::map<std::string, std::string> &env, const std::string &body, const std::string interpreter) : _scriptPath(path), _env(env), _body(body), _interpreter(interpreter) {}

CgiHandler::CgiHandler(const CgiHandler &copy)
{
	*this = copy;
}

CgiHandler &CgiHandler::operator=(const CgiHandler &other)
{
	if (this != &other)
	{
		_scriptPath = other._scriptPath;
		_env = other._env;
		_body = other._body;
	}
	return *this;
}

CgiHandler::~CgiHandler() {}

std::string CgiHandler::execute()
{
	int pipeIn[2];
	int pipeOut[2];
	pipe(pipeIn);
	pipe(pipeOut);
	std::string result;

	pid_t pid = fork();
	if (pid == 0)
	{
		dup2(pipeIn[0], STDIN_FILENO);
		dup2(pipeOut[1], STDOUT_FILENO);
		close(pipeIn[1]);
		close(pipeOut[0]);
		char *argv[] = {strdup(_interpreter.c_str()), strdup(_scriptPath.c_str()), NULL};
		char **envp = new char*[_env.size() + 1];
		int i = 0;
		for (std::map<std::string, std::string>::const_iterator it = _env.begin(); it != _env.end(); ++it)
		{
			std::string kv = it->first + "=" + it->second;
			envp[i] = strdup(kv.c_str());
			i++;
		}
		envp[i] = NULL;
		execve(_interpreter.c_str(), argv, envp);
		exit(1);
	}
	else
	{
		close(pipeIn[0]);
		close(pipeOut[1]);
		if (!_body.empty())
		{
			write(pipeIn[1], _body.c_str(), _body.size());
		}
		close(pipeIn[1]);

		char buffer[1024];
		ssize_t bytesRead;
		while ((bytesRead = read(pipeOut[0], buffer, sizeof(buffer))) > 0)
			result.append(buffer, bytesRead);
		close(pipeOut[0]);

		int status;
		waitpid(pid, &status, 0);
	}
	return result;
}-e 
===== ./src/Main.cpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:55:56 by pmilek            #+#    #+#             */
/*   Updated: 2025/06/12 11:24:22 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/Server.hpp"
#include "../includes/Webserv.hpp"
#include "../includes/HttpRequestParse.hpp"
#include "../includes/ConfigParser.hpp"

int main() {
	try {
		// ⬇Parsowanie pliku konfiguracyjnego
		ConfigParser parser("www/config.conf");
		parser.parse();
		ServerConfig config = parser.getServerConfig();

		// ⬇Wypisywanie sparsowanych danych (debug)
		std::cout << "Parsed Config:\n";
		std::cout << "Port: " << config.port << "\n";
		std::cout << "Root: " << config.root << "\n";
		std::cout << "Max body size: " << config.client_max_body_size << "\n";
		std::cout << "Server names:\n";
		for (size_t i = 0; i < config.server_names.size(); ++i)
			std::cout << "  " << config.server_names[i] << "\n";

		std::cout << "Error pages:\n";
		for (std::map<int, std::string>::iterator it = config.error_pages.begin(); it != config.error_pages.end(); ++it)
			std::cout << "  " << it->first << " => " << it->second << "\n";

		std::cout << "Locations:\n";
		for (size_t i = 0; i < config.locations.size(); ++i) {
			std::cout << "  Path: " << config.locations[i].path << "\n";
			std::cout << "    Methods: ";
			for (size_t j = 0; j < config.locations[i].methods.size(); ++j)
				std::cout << config.locations[i].methods[j] << " ";
			std::cout << "\n";
			std::cout << "    Upload path: " << config.locations[i].upload_path << "\n";
		}

		// Uruchomienie serwera z wczytaną konfiguracją
		Server server(config);
		server.setupSocket();
		server.run();

	} catch (const std::exception &e) {
		std::cerr << "❌ Error: " << e.what() << std::endl;
	}

	return 0;
}
-e 
===== ./src/Server.cpp =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpyciarz <jpyciarz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:56:03 by pmilek            #+#    #+#             */
/*   Updated: 2025/07/21 09:21:13 by jpyciarz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/Server.hpp"

// constructors, destructors, =operator
Server::Server(const ServerConfig &cfg) : config(cfg) {
	port = config.port;
	server_fd = -1;
}

Server::~Server() {}


// private methods
int Server::acceptConnection()
{
    socklen_t addrlen = sizeof(address);
    int client_fd = accept(server_fd, (sockaddr*)&address, &addrlen);
    if (client_fd < 0)
    {
        std::cerr << "failed to setup client_id" << std::endl;
        return 1;
    }
    return client_fd;
}

std::string Server::generateResponse(const HttpRequestParse &req)
{
    HttpResponse res(config);
	std::string response;
    response = res.buildResponse(req);
    return response;
}

void Server::sendResponse(int client_id, const std::string &response)
{
    write(client_id, response.c_str(), response.length());
}

std::string Server::reciveRequest(int client_fd)
{
    char buffer[1024];
    std::string request;
    ssize_t bytesRead;
    while ((bytesRead = read(client_fd, buffer, sizeof(buffer))) > 0)
    {
        request.append(buffer, bytesRead);
        if (request.find("\r\n\r\n") != std::string::npos)
            break ;
    }
    return request;
}

// public methods
void Server::setupSocket()
{
	server_fd = socket(AF_INET, SOCK_STREAM, 0);
	if (server_fd == -1) {
		std::cerr << "socket failed" << std::endl;
		return;
	}

	memset(&address, 0, sizeof(address));
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons(port);

	if (bind(server_fd, (sockaddr*)&address, sizeof(address)) < 0) {
		std::cerr << "bind failed" << std::endl;
		return;
	}
	if (listen(server_fd, 10) < 0) {
		std::cerr << "listen failed" << std::endl;
		return;
	}

	std::cout << "Server running at http://localhost:" << port << std::endl;
}

void Server::run()
{
    int client_id;
    std::string response;
    std::string clientRequest;
    while (true)
    {
        client_id = Server::acceptConnection();
        if (client_id < 0)
            continue;
        else
        {
            clientRequest = Server::reciveRequest(client_id);
            HttpRequestParse req(clientRequest);
            req.parseRequest();
            response = Server::generateResponse(req);
            Server::sendResponse(client_id, response);
            close(client_id);
        }
    }
}

// getters/setters
int Server::getPort()
{
    return port;
}