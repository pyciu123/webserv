-e 
===== ./Makefile =====
NAME = webserv

SRCS = $(wildcard src/*.cpp)
INC = $(wildcard includes/*.hpp)

all: $(NAME)

$(NAME): $(SRCS) $(INC)
	c++ -Wall -Wextra -Werror -std=c++98 -Iincludes $(SRCS) -o $(NAME)

clean:
	rm -f *.o

fclean: clean
	rm -f $(NAME)

re: fclean all-e 
===== ./includes/server.hpp =====
#ifndef SERVER_HPP
# define SERVER_HPP

#include "webserv.hpp"

class Server {
	private:
		int server_fd;
		int port;

	public:
		Server();
		Server(const Server &copy);
		Server &operator=(const Server &other);
		~Server();

		void setupSocket();
};

#endif-e 
===== ./includes/webserv.hpp =====
#ifndef WEBSERV_HPP
# define WEBSERV_HPP

// c
#include <netinet/in.h>
#include <sys/socket.h>

// c++
#include <iostream>
#include <cstring>

#endif-e 
===== ./src/main.cpp =====
-e 
===== ./src/server.cpp =====
#include  "../includes/server.hpp"

Server::Server() : port(8080), server_fd(-1) {}

Server::Server(const Server &copy)
{
    *this = copy;
}

Server &Server::operator=(const Server &other)
{
    this->server_fd = other.server_fd;
    return *this;
}

Server::~Server() {}

void Server::setupSocket()
{
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
    {
        std::cerr << "socked failed" << std::endl;
        return ;
    }
    sockaddr address;
    memset(&address, 0, sizeof(address));
    address.sa_family = AF_INET;
    address
}-e 
===== ./Makefile =====
NAME = webserv

SRCS = $(wildcard src/*.cpp)
INC = $(wildcard includes/*.hpp)

all: $(NAME)

$(NAME): $(SRCS) $(INC)
	c++ -Wall -Wextra -Werror -std=c++98 -Iincludes $(SRCS) -o $(NAME)

clean:
	rm -f *.o

fclean: clean
	rm -f $(NAME)

re: fclean all-e 
===== ./includes/server.hpp =====
#ifndef SERVER_HPP
# define SERVER_HPP

#include "webserv.hpp"

class Server {
	private:
		int server_fd;
		int client_fd;
		int port;
		sockaddr_in address;
		int acceptConnection();
		std::string handleRequest();
		void sendResponse(int client_fd, const std::string &response);

	public:
		Server();
		Server(const Server &copy);
		Server &operator=(const Server &other);
		~Server();

		// methods
		void setupSocket();
		void run();
		
		// getters
		int getPort();
};

#endif-e 
===== ./includes/webserv.hpp =====
#ifndef WEBSERV_HPP
# define WEBSERV_HPP

// c
#include <netinet/in.h>
#include <sys/socket.h>

// c++
#include <iostream>
#include <cstring>

#endif-e 
===== ./src/main.cpp =====
#include "../includes/server.hpp"
#include "../includes/webserv.hpp"

int main()
{
	
}-e 
===== ./src/server.cpp =====
#include  "../includes/server.hpp"

// constructors, destructors, =operator
Server::Server() : port(8080), server_fd(-1), client_fd(-1) {}

Server::Server(const Server &copy)
{
    *this = copy;
}

Server &Server::operator=(const Server &other)
{
    this->server_fd = other.server_fd;
    return *this;
}

Server::~Server() {}


// private methods
int Server::acceptConnection()
{
    client_fd = accept(server_fd, (sockaddr*)&address, sizeof(this->address));
}

int Server::getPort()
{
    return port;
}

void Server::setupSocket()
{
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
    {
        std::cerr << "socked failed" << std::endl;
        return ;
    }
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);
    if (bind(server_fd, (sockaddr*)&address, sizeof(address)) < 0)
    {
        std::cerr << "bind failed" << std::endl;
        return ;
    }
    if (listen(server_fd, -1) < 0)
    {
        std::cerr << "listen" << std::endl;
        return ;
    }
}
-e 
===== ./Makefile =====
NAME = webserv

SRCS = $(wildcard src/*.cpp)
INC = $(wildcard includes/*.hpp)

all: $(NAME)

$(NAME): $(SRCS) $(INC)
	c++ -Wall -Wextra -Werror -std=c++98 -Iincludes $(SRCS) -o $(NAME)

clean:
	rm -f *.o

fclean: clean
	rm -f $(NAME)

re: fclean all-e 
===== ./includes/server.hpp =====
#ifndef SERVER_HPP
# define SERVER_HPP

#include "webserv.hpp"

class Server {
	private:
		int server_fd;
		int port;
		sockaddr_in address;
		int acceptConnection();
		std::string handleRequest();
		void sendResponse(int client_id, const std::string &response);

	public:
		Server();
		Server(const Server &copy);
		Server &operator=(const Server &other);
		~Server();

		// methods
		void setupSocket();
		void run();
		
		// getters
		int getPort();
};

#endif-e 
===== ./includes/webserv.hpp =====
#ifndef WEBSERV_HPP
# define WEBSERV_HPP

// c
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

// c++
#include <iostream>
#include <cstring>

#endif-e 
===== ./src/main.cpp =====
#include "../includes/server.hpp"
#include "../includes/webserv.hpp"

int main()
{
	
}-e 
===== ./src/server.cpp =====
#include  "../includes/server.hpp"

// constructors, destructors, =operator
Server::Server() : port(8080), server_fd(-1) {}

Server::Server(const Server &copy)
{
    *this = copy;
}

Server &Server::operator=(const Server &other)
{
    this->server_fd = other.server_fd;
    return *this;
}

Server::~Server() {}


// private methods
int Server::acceptConnection()
{
    socklen_t addrlen = sizeof(address);
    int client_fd = accept(server_fd, (sockaddr*)&address, &addrlen);
    if (client_fd < 0)
    {
        std::cerr << "failed to setup client_id" << std::endl;
        return 1;
    }
    return client_fd;
}

std::string Server::handleRequest()
{
    std::string response =
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 14\r\n"
            "\r\n"
            "chuj ci w dupe";
    return response;
}

void Server::sendResponse(int client_id, const std::string &response)
{
    write(client_id, response.c_str(), response.length());
}


// public methods
void Server::setupSocket()
{
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
    {
        std::cerr << "socked failed" << std::endl;
        return ;
    }
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);
    if (bind(server_fd, (sockaddr*)&address, sizeof(address)) < 0)
    {
        std::cerr << "bind failed" << std::endl;
        return ;
    }
    if (listen(server_fd, -1) < 0)
    {
        std::cerr << "listen" << std::endl;
        return ;
    }
}

void Server::run()
{
    int client_id;
    std::string response;
    while (true)
    {
        client_id = Server::acceptConnection();
        if (client_id < 0)
            continue;
        else
        {
            response = Server::handleRequest();
            Server::sendResponse(client_id, response);
        }
    }
}


// getters/setters
int Server::getPort()
{
    return port;
}-e 
===== ./Makefile =====
NAME = webserv

SRCS = $(wildcard src/*.cpp)
INC = $(wildcard includes/*.hpp)

all: $(NAME)

$(NAME): $(SRCS) $(INC)
	c++ -Wall -Wextra -Werror -std=c++98 -Iincludes $(SRCS) -o $(NAME)

clean:
	rm -f *.o

fclean: clean
	rm -f $(NAME)

re: fclean all-e 
===== ./includes/server.hpp =====
#ifndef SERVER_HPP
# define SERVER_HPP

#include "webserv.hpp"

class Server {
	private:
		int server_fd;
		int port;
		sockaddr_in address;
		int acceptConnection();
		std::string handleRequest();
		void sendResponse(int client_id, const std::string &response);

	public:
		Server();
		Server(const Server &copy);
		Server &operator=(const Server &other);
		~Server();

		// methods
		void setupSocket();
		void run();
		
		// getters
		int getPort();
};

#endif-e 
===== ./includes/webserv.hpp =====
#ifndef WEBSERV_HPP
# define WEBSERV_HPP

// c
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

// c++
#include <iostream>
#include <cstring>

#endif-e 
===== ./src/main.cpp =====
#include "../includes/server.hpp"
#include "../includes/webserv.hpp"

int main()
{
	
}-e 
===== ./src/server.cpp =====
#include  "../includes/server.hpp"

// constructors, destructors, =operator
Server::Server() : port(8080), server_fd(-1) {}

Server::Server(const Server &copy)
{
    *this = copy;
}

Server &Server::operator=(const Server &other)
{
    this->server_fd = other.server_fd;
    return *this;
}

Server::~Server() {}


// private methods
int Server::acceptConnection()
{
    socklen_t addrlen = sizeof(address);
    int client_fd = accept(server_fd, (sockaddr*)&address, &addrlen);
    if (client_fd < 0)
    {
        std::cerr << "failed to setup client_id" << std::endl;
        return 1;
    }
    return client_fd;
}

std::string Server::handleRequest()
{
    std::string response =
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 14\r\n"
            "\r\n"
            "chuj ci w dupe";
    return response;
}

void Server::sendResponse(int client_id, const std::string &response)
{
    write(client_id, response.c_str(), response.length());
}


// public methods
void Server::setupSocket()
{
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1)
    {
        std::cerr << "socked failed" << std::endl;
        return ;
    }
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);
    if (bind(server_fd, (sockaddr*)&address, sizeof(address)) < 0)
    {
        std::cerr << "bind failed" << std::endl;
        return ;
    }
    if (listen(server_fd, 10) < 0)
    {
        std::cerr << "listen" << std::endl;
        return ;
    }
}

void Server::run()
{
    int client_id;
    std::string response;
    while (true)
    {
        client_id = Server::acceptConnection();
        if (client_id < 0)
            continue;
        else
        {
            response = Server::handleRequest();
            Server::sendResponse(client_id, response);
            close(client_id);
        }
    }
}


// getters/setters
int Server::getPort()
{
    return port;
}